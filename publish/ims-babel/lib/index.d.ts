import * as ts from 'typescript';
export declare function traverse(node: ts.Node): NodePath<ts.Node>;
declare class NodePath<T extends ts.Node = ts.Node> {
    parentPath: NodePath;
    child: NodePath;
    children: NodePath[];
    parent: ts.Node;
    node: ts.Node;
    constructor(node: T | ts.NodeArray<T>);
    isNodeArray(node: any): node is ts.NodeArray<T>;
    traverse(visitor: any): void;
    isVariableDeclaration(): this is NodePath<ts.VariableDeclaration>;
    isAccessor(): this is NodePath<ts.AccessorDeclaration>;
    isArrayBindingPattern(): this is NodePath<ts.ArrayBindingPattern>;
    isArrayLiteralExpression(): this is NodePath<ts.ArrayLiteralExpression>;
    isArrayTypeNode(): this is NodePath<ts.ArrayTypeNode>;
    isArrowFunction(): this is NodePath<ts.ArrowFunction>;
    isAsExpression(): this is NodePath<ts.AsExpression>;
    isAwaitExpression(): this is NodePath<ts.AwaitExpression>;
    isAssertionExpression(): this is NodePath<ts.AssertionExpression>;
    isBigIntLiteral(): this is NodePath<ts.BigIntLiteral>;
    isBinaryExpression(): this is NodePath<ts.BinaryExpression>;
    isBindingElement(): this is NodePath<ts.BindingElement>;
    isBindingName(): this is NodePath<ts.BindingName>;
    isBlock(): this is NodePath<ts.Block>;
    isBreakOrContinueStatement(): this is NodePath<ts.BreakOrContinueStatement>;
    isBreakStatement(): this is NodePath<ts.BreakStatement>;
    isBundle(): this is NodePath<ts.Bundle>;
}
export {};
